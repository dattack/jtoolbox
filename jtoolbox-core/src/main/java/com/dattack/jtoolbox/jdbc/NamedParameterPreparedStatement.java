/*
 * Copyright (c) 2017, The Dattack team (http://www.dattack.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dattack.jtoolbox.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Useful class to prepare and execute a SQL with parameter-name instead of parameter-index. The parameter-name is
 * identified by the format <i>:param_name</i>.
 *
 * @author cvarela
 * @since 0.2
 */
@SuppressWarnings({"PMD.LongVariable", "PMD.ExcessivePublicCount", "PMD.AccessorMethodGeneration", //
        "PMD.CyclomaticComplexity", "checkstyle:AbbreviationAsWordInName"})
public class NamedParameterPreparedStatement extends DelegatingPreparedStatement {

    private final transient PreparedStatementConfig preparedStatementConfig;

    private NamedParameterPreparedStatement(final PreparedStatement delegate,
                                            final PreparedStatementConfig preparedStatementConfig) {
        super(delegate);
        this.preparedStatementConfig = preparedStatementConfig;
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection a connection (session) with a specific database.
     * @param sql        a SQL statement that may contain one or more ':parameterName' IN parameter placeholders
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql)
            throws SQLException {

        final PreparedStatementConfig preparedStatementConfig = PreparedStatementConfig.parse(sql);
        return new NamedParameterPreparedStatement(connection.prepareStatement(//
                preparedStatementConfig.getCompiledSql()), //
                preparedStatementConfig);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection        a connection (session) with a specific database.
     * @param sql               a SQL statement that may contain one or more ':parameterName' IN parameter
     *                          placeholders
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int autoGeneratedKeys) throws SQLException {
        final PreparedStatementConfig preparedStatementConfig = PreparedStatementConfig.parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(preparedStatementConfig.getCompiledSql(), autoGeneratedKeys),
                preparedStatementConfig);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection           a connection (session) with a specific database.
     * @param sql                  a SQL statement that may contain one or more ':parameterName' IN parameter
     *                             placeholders
     * @param resultSetType        one of the following <code>ResultSet</code> constants:
     *                             <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *                             <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>,
     *                             or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @param resultSetConcurrency one of the following <code>ResultSet</code> constants: <code>ResultSet
     *                             .CONCUR_READ_ONLY</code> or
     *                             <code>ResultSet.CONCUR_UPDATABLE</code>
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    @SuppressWarnings("PMD.LongVariable")
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int resultSetType, final int resultSetConcurrency)
            throws SQLException {
        final PreparedStatementConfig preparedStatementConfig = PreparedStatementConfig.parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(preparedStatementConfig.getCompiledSql(), resultSetType,
                        resultSetConcurrency), //
                preparedStatementConfig);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection           a connection (session) with a specific database.
     * @param sql                  a SQL statement that may contain one or more ':parameterName' IN parameter
     *                             placeholders
     * @param resultSetType        one of the following <code>ResultSet</code> constants:
     *                             <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *                             <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
     *                             <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @param resultSetConcurrency one of the following <code>ResultSet</code> constants: <code>ResultSet
     *                             .CONCUR_READ_ONLY</code> or <code>ResultSet.CONCUR_UPDATABLE</code>
     * @param resultSetHoldability one of the following <code>ResultSet</code> constants: <code>ResultSet
     *                             .HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int resultSetType, final int resultSetConcurrency,
                                                        final int resultSetHoldability)
            throws SQLException {
        final PreparedStatementConfig preparedStatementConfig = PreparedStatementConfig.parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(preparedStatementConfig.getCompiledSql(), resultSetType,
                        resultSetConcurrency,
                        resultSetHoldability), //
                preparedStatementConfig);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection    a connection (session) with a specific database.
     * @param sql           a SQL statement that may contain one or more ':parameterName' IN parameter placeholders
     * @param columnIndexes an array of column indexes indicating the columns that should be returned from the
     *                      inserted row or rows
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    @SuppressWarnings("PMD.UseVarargs")
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int[] columnIndexes) throws SQLException {
        final PreparedStatementConfig preparedStatementConfig = PreparedStatementConfig.parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(preparedStatementConfig.getCompiledSql(), columnIndexes), //
                preparedStatementConfig);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection  a connection (session) with a specific database.
     * @param sql         a SQL statement that may contain one or more ':parameterName' IN parameter placeholders *
     * @param columnNames an array of column names indicating the columns that should be returned from the inserted
     *                    row or rows
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    @SuppressWarnings("PMD.UseVarargs")
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final String[] columnNames) throws SQLException {
        final PreparedStatementConfig preparedStatementConfig = PreparedStatementConfig.parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(preparedStatementConfig.getCompiledSql(), columnNames), //
                preparedStatementConfig);
    }

    public boolean hasNamedParameter(final String parameter) {
        return preparedStatementConfig.hasNamedParameter(parameter);
    }

    public boolean hasNamedParameters() {
        return preparedStatementConfig.hasNamedParameters();
    }

    /**
     * {@link #setArray(int, Array)}.
     *
     * @param parameterName the parameter name
     * @param value         an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
     * @throws SQLException                    if parameterName does not correspond to a parameter marker in the SQL
     *                                         statement; if a
     *                                         database access error occurs or this method is called on a closed
     *                                         PreparedStatement
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public void setArray(final String parameterName, final Array value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setArray(i, value);
        }
    }

    /**
     * {@link #setAsciiStream(int, InputStream)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(final String parameterName, final InputStream value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setAsciiStream(i, value);
        }
    }

    /**
     * {@link #setAsciiStream(int, InputStream, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the Java input stream that contains the ASCII parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(final String parameterName, final InputStream value, final int length)
            throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setAsciiStream(i, value, length);
        }
    }

    /**
     * {@link #setAsciiStream(int, InputStream, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(final String parameterName, final InputStream value, final long length)
            throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setAsciiStream(index, value, length);
        }
    }

    /**
     * {@link #setBigDecimal(int, BigDecimal)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBigDecimal(final String parameterName, final BigDecimal value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBigDecimal(i, value);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(final String parameterName, final InputStream value, final int length)
            throws SQLException {

        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBinaryStream(i, value, length);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(final String parameterName, final InputStream value, final long length)
            throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBinaryStream(index, value, length);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(final String parameterName, final InputStream value) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBinaryStream(index, value);
        }
    }

    /**
     * {@link #setBlob(int, Blob)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(final String parameterName, final Blob value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBlob(i, value);
        }
    }

    /**
     * {@link #setBlob(int, InputStream, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(final String parameterName, final InputStream value, final long length) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBlob(index, value, length);
        }
    }

    /**
     * {@link #setBlob(int, InputStream)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(final String parameterName, final InputStream value) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBlob(index, value);
        }
    }

    /**
     * {@link #setBoolean(int, boolean)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBoolean(final String parameterName, final boolean value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBoolean(i, value);
        }
    }

    /**
     * {@link #setByte(int, byte)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setByte(final String parameterName, final byte value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setByte(i, value);
        }
    }

    /**
     * {@link #setBytes(int, byte[])}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBytes(final String parameterName, final byte[] value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setBytes(i, value);
        }
    }

    /**
     * {@link #setCharacterStream(int, Reader, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the <code>java.io.Reader</code> object that contains the
     *                      Unicode data
     * @param length        the number of characters in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setCharacterStream(final String parameterName, final Reader value, final int length)
            throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setCharacterStream(i, value, length);
        }
    }

    /**
     * {@link #setCharacterStream(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setCharacterStream(final String parameterName, final Reader value, final long length)
            throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setCharacterStream(index, value, length);
        }
    }

    /**
     * {@link #setCharacterStream(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setCharacterStream(final String parameterName, final Reader value) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setCharacterStream(index, value);
        }
    }

    /**
     * {@link #setClob(int, Clob)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(final String parameterName, final Clob value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setClob(i, value);
        }
    }

    /**
     * {@link #setClob(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(final String parameterName, final Reader value, final long length) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setClob(i, value, length);
        }
    }

    /**
     * {@link #setClob(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(final String parameterName, final Reader value) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setClob(index, value);
        }
    }

    /**
     * {@link #setDate(int, Date)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setDate(final String parameterName, final Date value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setDate(i, value);
        }
    }

    /**
     * {@link #setDate(int, Date, Calendar)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param cal           the <code>Calendar</code> object the driver will use
     *                      to construct the date
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setDate(final String parameterName, final Date value, final Calendar cal) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setDate(i, value, cal);
        }
    }

    /**
     * {@link #setDouble(int, double)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setDouble(final String parameterName, final double value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setDouble(i, value);
        }
    }

    /**
     * {@link #setFloat(int, float)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setFloat(final String parameterName, final float value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setFloat(i, value);
        }
    }

    /**
     * {@link #setInt(int, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setInt(final String parameterName, final int value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setInt(i, value);
        }
    }

    /**
     * {@link #setLong(int, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setLong(final String parameterName, final long value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setLong(i, value);
        }
    }

    /**
     * {@link #setNCharacterStream(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNCharacterStream(final String parameterName, final Reader value, final long length)
            throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNCharacterStream(i, value, length);
        }
    }

    /**
     * {@link #setNCharacterStream(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNCharacterStream(final String parameterName, final Reader value) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNCharacterStream(index, value);
        }
    }

    /**
     * {@link #setNClob(int, NClob)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNClob(final String parameterName, final NClob value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNClob(i, value);
        }
    }

    /**
     * {@link #setNClob(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNClob(final String parameterName, final Reader value, final long length) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNClob(index, value, length);
        }
    }

    /**
     * {@link #setNClob(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNClob(final String parameterName, final Reader value) throws SQLException {
        for (final Integer index : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNClob(index, value);
        }
    }

    /**
     * {@link #setNString(int, String)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNString(final String parameterName, final String value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNString(i, value);
        }
    }

    /**
     * {@link #setNull(int, int)}.
     *
     * @param parameterName the parameter name
     * @param sqlType       the SQL type code defined in <code>java.sql.Types</code>
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNull(final String parameterName, final int sqlType) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNull(i, sqlType);
        }
    }

    /**
     * {@link #setNull(int, int, String)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param typeName      the fully-qualified name of an SQL user-defined type;
     *                      ignored if the parameter is not a user-defined type or REF
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNull(final String parameterName, final int value, final String typeName) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setNull(i, value, typeName);
        }
    }

    /**
     * {@link #setObject(int, Object)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String parameterName, final Object value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setObject(i, value);
        }
    }

    /**
     * {@link #setObject(int, Object, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be sent to the database. The scale
     *                      argument may further qualify this type.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String parameterName, final Object value, final int targetSqlType) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setObject(i, value, targetSqlType);
        }
    }

    /**
     * {@link #setObject(int, Object, int, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be sent to the database. The scale
     *                      argument may further
     *                      qualify this type.
     * @param scaleOrLength for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types, this is the number of digits
     *                      after the
     *                      decimal point. For Java Object types InputStream and Reader, this is the length of the
     *                      data in the
     *                      stream or reader. For all other types, this value will be ignored.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String parameterName, final Object value, final int targetSqlType,
                          final int scaleOrLength)
            throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setObject(i, value, targetSqlType, scaleOrLength);
        }
    }

    /**
     * {@link #setRef(int, Ref)}.
     *
     * @param parameterName the parameter name
     * @param value         an SQL <code>REF</code> value
     * @throws SQLException                    if parameterName does not correspond to a parameter marker in the SQL
     *                                         statement; if a
     *                                         database access error occurs or this method is called on a closed
     *                                         PreparedStatement
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public void setRef(final String parameterName, final Ref value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setRef(i, value);
        }
    }

    /**
     * {@link #setRowId(int, RowId)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setRowId(final String parameterName, final RowId value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setRowId(i, value);
        }
    }

    /**
     * {@link #setSQLXML(int, SQLXML)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setSQLXML(final String parameterName, final SQLXML value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setSQLXML(i, value);
        }
    }

    /**
     * {@link #setShort(int, short)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("PMD.AvoidUsingShortType")
    public void setShort(final String parameterName, final short value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setShort(i, value);
        }
    }

    /**
     * {@link #setString(int, String)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setString(final String parameterName, final String value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setString(i, value);
        }
    }

    /**
     * {@link #setTime(int, Time)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTime(final String parameterName, final Time value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setTime(i, value);
        }
    }

    /**
     * {@link #setTime(int, Time, Calendar)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param cal           the <code>Calendar</code> object the driver will use
     *                      to construct the time
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTime(final String parameterName, final Time value, final Calendar cal) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setTime(i, value, cal);
        }
    }

    /**
     * {@link #setTimestamp(int, Timestamp)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTimestamp(final String parameterName, final Timestamp value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setTimestamp(i, value);
        }
    }

    /**
     * {@link #setTimestamp(int, Timestamp, Calendar)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param cal           the <code>Calendar</code> object the driver will use
     *                      to construct the timestamp
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTimestamp(final String parameterName, final Timestamp value, final Calendar cal)
            throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setTimestamp(i, value, cal);
        }
    }

    /**
     * {@link #setURL(int, URL)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setURL(final String parameterName, final URL value) throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setURL(i, value);
        }
    }

    /**
     * {@link #setUnicodeStream(int, InputStream, int)}.
     *
     * @param parameterName the parameter name
     * @param value         a java.io.InputStream object that contains the Unicode parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @Deprecated
    public void setUnicodeStream(final String parameterName, final InputStream value, final int length)
            throws SQLException {
        for (final Integer i : preparedStatementConfig.getParameterIndexes(parameterName)) {
            getDelegate().setUnicodeStream(i, value, length);
        }
    }

    /**
     * Internal representation of a PreparedStatement.
     */
    private static final class PreparedStatementConfig {

        private transient String compiledSql;
        private final transient Map<String, List<Integer>> parameterName2IndexMap;
        private transient int parameterIndex;

        private PreparedStatementConfig() {
            this.parameterIndex = 1;
            this.parameterName2IndexMap = new HashMap<>();
        }

        private void addParameter(final String parameterName) {

            final String normalizedName = normalizeParameterName(parameterName);
            final List<Integer> list = parameterName2IndexMap.computeIfAbsent(normalizedName, k -> new ArrayList<>());
            list.add(parameterIndex++);
        }

        private static String normalizeParameterName(final String parameterName) {
            return parameterName.toLowerCase(Locale.getDefault());
        }

        private void setCompiledSql(final String compiledSql) {
            this.compiledSql = compiledSql;
        }

        private String getCompiledSql() {
            return compiledSql;
        }

        private Collection<Integer> getParameterIndexes(final String parameterName) {

            final String normalizedName = normalizeParameterName(parameterName);
            final List<Integer> indexes = parameterName2IndexMap.get(normalizedName);

            if (indexes.isEmpty()) {
                throw new IllegalArgumentException(String.format("Parameter not found: '%s'", normalizedName));
            }
            return indexes;
        }

        private boolean hasNamedParameter(final String parameterName) {
            return parameterName2IndexMap.containsKey(normalizeParameterName(parameterName));
        }

        private boolean hasNamedParameters() {
            return !parameterName2IndexMap.isEmpty();
        }


        /**
         * Parse the query string containing named parameters and result a parse result, which holds the parsed sql
         * (named
         * parameters replaced by standard '?' parameters and an ordered list of the named parameters.
         *
         * @param query Query containing named parameters
         * @return ParseResult
         */
        @SuppressWarnings({"PMD.CyclomaticComplexity", "PMD.AvoidLiteralsInIfCondition"})
        private static PreparedStatementConfig parse(final String query) {

            final int length = query.length();
            boolean inSingleQuote = false;
            boolean inDoubleQuote = false;
            boolean inSingleLineComment = false;
            boolean inMultiLineComment = false;

            final StringBuilder compiledSql = new StringBuilder(length);
            final PreparedStatementConfig preparedStatementConfig = new PreparedStatementConfig();

            int index = 0;
            while (index < length) {
                char currentChar = query.charAt(index);
                if (inSingleQuote) {
                    if (currentChar == '\'') {
                        inSingleQuote = false; // '...'
                    }
                } else if (inDoubleQuote) {
                    if (currentChar == '"') {
                        inDoubleQuote = false; // "..."
                    }
                } else if (inMultiLineComment) {
                    if (currentChar == '*' && index < length - 1 && query.charAt(index + 1) == '/') {
                        inMultiLineComment = false; // */
                    }
                } else if (inSingleLineComment) {
                    if (currentChar == '\n') {
                        inSingleLineComment = false;
                    }
                } else {
                    if (currentChar == '\'') { // '...
                        inSingleQuote = true;
                    } else if (currentChar == '"') {
                        inDoubleQuote = true;
                    } else if (currentChar == '/' && index < length - 1 && query.charAt(index + 1) == '*') { // /*
                        inMultiLineComment = true;
                    } else if (currentChar == '-' && index < length - 1 && query.charAt(index + 1) == '-') { // --
                        inSingleLineComment = true;
                    } else if (currentChar == ':' //
                            && index + 1 < length //
                            && Character.isJavaIdentifierStart(query.charAt(index + 1))) {
                        int skipCharacters = index + 2;
                        while (skipCharacters < length
                                && Character.isJavaIdentifierPart(query.charAt(skipCharacters))) {
                            skipCharacters++;
                        }
                        final String name = query.substring(index + 1, skipCharacters);
                        preparedStatementConfig.addParameter(name);
                        currentChar = '?';
                        index += name.length();
                    }
                }
                compiledSql.append(currentChar);
                index++;
            }

            preparedStatementConfig.setCompiledSql(compiledSql.toString());

            return preparedStatementConfig;
        }
    }
}
