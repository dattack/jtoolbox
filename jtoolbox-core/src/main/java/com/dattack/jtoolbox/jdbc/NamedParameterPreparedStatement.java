/*
 * Copyright (c) 2017, The Dattack team (http://www.dattack.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dattack.jtoolbox.jdbc;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Useful class to prepare and execute a SQL with parameter-name instead of parameter-index. The parameter-name is
 * identified by the format <i>:param_name</i>.
 *
 * @author cvarela
 * @since 0.2
 */
public class NamedParameterPreparedStatement extends DelegatingPreparedStatement {

    private final ParseResult parseResult;

    private NamedParameterPreparedStatement(final PreparedStatement delegate, final ParseResult parseResult) {
        super(delegate);
        this.parseResult = parseResult;
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection a connection (session) with a specific database.
     * @param sql        a SQL statement that may contain one or more ':parameterName' IN parameter placeholders
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql)
            throws SQLException {

        final ParseResult parseResult = parse(sql);

        return new NamedParameterPreparedStatement(connection.prepareStatement(parseResult.getCompiledSql()), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection        a connection (session) with a specific database.
     * @param sql               a SQL statement that may contain one or more ':parameterName' IN parameter
     *                          placeholders
     * @param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int autoGeneratedKeys) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(parseResult.getCompiledSql(), autoGeneratedKeys), parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection           a connection (session) with a specific database.
     * @param sql                  a SQL statement that may contain one or more ':parameterName' IN parameter
     *                             placeholders
     * @param resultSetType        one of the following <code>ResultSet</code> constants:
     *                             <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *                             <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>,
     *                             or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @param resultSetConcurrency one of the following <code>ResultSet</code> constants: <code>ResultSet
     *                             .CONCUR_READ_ONLY</code> or
     *                             <code>ResultSet.CONCUR_UPDATABLE</code>
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int resultSetType, final int resultSetConcurrency)
            throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(parseResult.getCompiledSql(), resultSetType, resultSetConcurrency), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection           a connection (session) with a specific database.
     * @param sql                  a SQL statement that may contain one or more ':parameterName' IN parameter
     *                             placeholders
     * @param resultSetType        one of the following <code>ResultSet</code> constants:
     *                             <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *                             <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
     *                             <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @param resultSetConcurrency one of the following <code>ResultSet</code> constants: <code>ResultSet
     *                             .CONCUR_READ_ONLY</code> or <code>ResultSet.CONCUR_UPDATABLE</code>
     * @param resultSetHoldability one of the following <code>ResultSet</code> constants: <code>ResultSet
     *                             .HOLD_CURSORS_OVER_COMMIT</code> or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int resultSetType, final int resultSetConcurrency,
                                                        final int resultSetHoldability)
            throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(parseResult.getCompiledSql(), resultSetType, resultSetConcurrency,
                        resultSetHoldability), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection    a connection (session) with a specific database.
     * @param sql           a SQL statement that may contain one or more ':parameterName' IN parameter placeholders
     * @param columnIndexes an array of column indexes indicating the columns that should be returned from the
     *                      inserted row or rows
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final int[] columnIndexes) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(parseResult.getCompiledSql(), columnIndexes), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection  a connection (session) with a specific database.
     * @param sql         a SQL statement that may contain one or more ':parameterName' IN parameter placeholders *
     * @param columnNames an array of column names indicating the columns that should be returned from the inserted
     *                    row or rows
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @throws SQLException if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
                                                        final String[] columnNames) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement(//
                connection.prepareStatement(parseResult.getCompiledSql(), columnNames), //
                parseResult);
    }

    public boolean hasNamedParameter(final String parameter) {
        return parseResult.hasNamedParameter(parameter);
    }

    public boolean hasNamedParameters() {
        return parseResult.hasNamedParameters();
    }

    /**
     * {@link #setArray(int, Array)}.
     *
     * @param parameterName the parameter name
     * @param value         an <code>Array</code> object that maps an SQL <code>ARRAY</code> value
     * @throws SQLException                    if parameterName does not correspond to a parameter marker in the SQL
     *                                         statement; if a
     *                                         database access error occurs or this method is called on a closed
     *                                         PreparedStatement
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public void setArray(String parameterName, Array value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setArray(i, value);
        }
    }

    /**
     * {@link #setAsciiStream(int, InputStream)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(final String parameterName, final InputStream value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setAsciiStream(i, value);
        }
    }

    /**
     * {@link #setAsciiStream(int, InputStream, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the Java input stream that contains the ASCII parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(String parameterName, InputStream value, int length) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setAsciiStream(i, value, length);
        }
    }

    /**
     * {@link #setAsciiStream(int, InputStream, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(String parameterName, InputStream value, long length) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setAsciiStream(index, value, length);
        }
    }

    /**
     * {@link #setBigDecimal(int, BigDecimal)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBigDecimal(final String parameterName, final BigDecimal value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBigDecimal(i, value);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(final String parameterName, final InputStream value, final int length)
            throws SQLException {

        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBinaryStream(i, value, length);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(String parameterName, InputStream value, long length) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBinaryStream(index, value, length);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(String parameterName, InputStream value) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBinaryStream(index, value);
        }
    }

    /**
     * {@link #setBlob(int, Blob)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(final String parameterName, final Blob value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBlob(i, value);
        }
    }

    /**
     * {@link #setBlob(int, InputStream, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(String parameterName, InputStream value, long length) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBlob(index, value, length);
        }
    }

    /**
     * {@link #setBlob(int, InputStream)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(String parameterName, InputStream value) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBlob(index, value);
        }
    }

    /**
     * {@link #setBoolean(int, boolean)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBoolean(final String parameterName, final boolean value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBoolean(i, value);
        }
    }

    /**
     * {@link #setByte(int, byte)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setByte(final String parameterName, final byte value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setByte(i, value);
        }
    }

    /**
     * {@link #setBytes(int, byte[])}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setBytes(final String parameterName, final byte[] value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setBytes(i, value);
        }
    }

    /**
     * {@link #setCharacterStream(int, Reader, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the <code>java.io.Reader</code> object that contains the
     *                      Unicode data
     * @param length        the number of characters in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setCharacterStream(String parameterName, Reader value, int length) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setCharacterStream(i, value, length);
        }
    }

    /**
     * {@link #setCharacterStream(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setCharacterStream(String parameterName, Reader value, long length) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setCharacterStream(index, value, length);
        }
    }

    /**
     * {@link #setCharacterStream(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setCharacterStream(String parameterName, Reader value) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setCharacterStream(index, value);
        }
    }

    /**
     * {@link #setClob(int, Clob)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(final String parameterName, final Clob value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setClob(i, value);
        }
    }

    /**
     * {@link #setClob(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(String parameterName, Reader value, long length) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setClob(i, value, length);
        }
    }

    /**
     * {@link #setClob(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(String parameterName, Reader value) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setClob(index, value);
        }
    }

    /**
     * {@link #setDate(int, Date)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setDate(final String parameterName, final Date value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setDate(i, value);
        }
    }

    /**
     * {@link #setDate(int, Date, Calendar)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param cal           the <code>Calendar</code> object the driver will use
     *                      to construct the date
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setDate(String parameterName, Date value, Calendar cal) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setDate(i, value, cal);
        }
    }

    /**
     * {@link #setDouble(int, double)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setDouble(final String parameterName, final double value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setDouble(i, value);
        }
    }

    /**
     * {@link #setFloat(int, float)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setFloat(final String parameterName, final float value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setFloat(i, value);
        }
    }

    /**
     * {@link #setInt(int, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setInt(final String parameterName, final int value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setInt(i, value);
        }
    }

    /**
     * {@link #setLong(int, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setLong(final String parameterName, final long value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setLong(i, value);
        }
    }

    /**
     * {@link #setNCharacterStream(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNCharacterStream(i, value, length);
        }
    }

    /**
     * {@link #setNCharacterStream(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setNCharacterStream(String parameterName, Reader value) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNCharacterStream(index, value);
        }
    }

    /**
     * {@link #setNClob(int, NClob)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setNClob(final String parameterName, final NClob value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNClob(i, value);
        }
    }

    /**
     * {@link #setNClob(int, Reader, long)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param length        the number of characters in the parameter data.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setNClob(String parameterName, Reader value, long length) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNClob(index, value, length);
        }
    }

    /**
     * {@link #setNClob(int, Reader)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setNClob(String parameterName, Reader value) throws SQLException {
        for (final Integer index : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNClob(index, value);
        }
    }

    /**
     * {@link #setNString(int, String)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setNString(final String parameterName, final String value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNString(i, value);
        }
    }

    /**
     * {@link #setNull(int, int)}.
     *
     * @param parameterName the parameter name
     * @param sqlType       the SQL type code defined in <code>java.sql.Types</code>
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNull(final String parameterName, final int sqlType) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNull(i, sqlType);
        }
    }

    /**
     * {@link #setNull(int, int, String)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param typeName      the fully-qualified name of an SQL user-defined type;
     *                      ignored if the parameter is not a user-defined type or REF
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setNull(String parameterName, int value, String typeName) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setNull(i, value, typeName);
        }
    }

    /**
     * {@link #setObject(int, Object)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String parameterName, final Object value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setObject(i, value);
        }
    }

    /**
     * {@link #setObject(int, Object, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be sent to the database. The scale
     *                      argument may further qualify this type.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String parameterName, final Object value, final int targetSqlType) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setObject(i, value, targetSqlType);
        }
    }

    /**
     * {@link #setObject(int, Object, int, int)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param targetSqlType the SQL type (as defined in java.sql.Types) to be sent to the database. The scale
     *                      argument may further
     *                      qualify this type.
     * @param scaleOrLength for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types, this is the number of digits
     *                      after the
     *                      decimal point. For Java Object types InputStream and Reader, this is the length of the
     *                      data in the
     *                      stream or reader. For all other types, this value will be ignored.
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String parameterName, final Object value, final int targetSqlType,
                          final int scaleOrLength)
            throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setObject(i, value, targetSqlType, scaleOrLength);
        }
    }

    /**
     * {@link #setRef(int, Ref)}.
     *
     * @param parameterName the parameter name
     * @param value         an SQL <code>REF</code> value
     * @throws SQLException                    if parameterName does not correspond to a parameter marker in the SQL
     *                                         statement; if a
     *                                         database access error occurs or this method is called on a closed
     *                                         PreparedStatement
     * @throws SQLFeatureNotSupportedException if the JDBC driver does not support this method
     */
    public void setRef(String parameterName, Ref value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setRef(i, value);
        }
    }

    /**
     * {@link #setRowId(int, RowId)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setRowId(String parameterName, RowId value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setRowId(i, value);
        }
    }

    /**
     * {@link #setSQLXML(int, SQLXML)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setSQLXML(final String parameterName, SQLXML value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setSQLXML(i, value);
        }
    }

    /**
     * {@link #setShort(int, short)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setShort(final String parameterName, final short value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setShort(i, value);
        }
    }

    /**
     * {@link #setString(int, String)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setString(final String parameterName, final String value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setString(i, value);
        }
    }

    /**
     * {@link #setTime(int, Time)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTime(final String parameterName, final Time value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setTime(i, value);
        }
    }

    /**
     * {@link #setTime(int, Time, Calendar)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param cal           the <code>Calendar</code> object the driver will use
     *                      to construct the time
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTime(String parameterName, Time value, Calendar cal) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setTime(i, value, cal);
        }
    }

    /**
     * {@link #setTimestamp(int, Timestamp)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTimestamp(final String parameterName, final Timestamp value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setTimestamp(i, value);
        }
    }

    /**
     * {@link #setTimestamp(int, Timestamp, Calendar)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @param cal           the <code>Calendar</code> object the driver will use
     *                      to construct the timestamp
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    public void setTimestamp(String parameterName, Timestamp value, Calendar cal) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setTimestamp(i, value, cal);
        }
    }

    /**
     * {@link #setURL(int, URL)}.
     *
     * @param parameterName the parameter name
     * @param value         the parameter value
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @SuppressWarnings("checkstyle:AbbreviationAsWordInName")
    public void setURL(String parameterName, URL value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setURL(i, value);
        }
    }

    /**
     * {@link #setUnicodeStream(int, InputStream, int)}.
     *
     * @param parameterName the parameter name
     * @param value         a java.io.InputStream object that contains the Unicode parameter value
     * @param length        the number of bytes in the stream
     * @throws SQLException if parameterName does not correspond to a parameter marker in the SQL statement; if a
     *                      database access error occurs or this method is called on a closed PreparedStatement
     */
    @Deprecated
    public void setUnicodeStream(final String parameterName, final InputStream value, final int length)
            throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(parameterName)) {
            getDelegate().setUnicodeStream(i, value, length);
        }
    }


    /**
     * Parse the query string containing named parameters and result a parse result, which holds the parsed sql (named
     * parameters replaced by standard '?' parameters and an ordered list of the named parameters.
     *
     * @param query Query containing named parameters
     * @return ParseResult
     */
    private static ParseResult parse(final String query) {

        final int length = query.length();
        boolean inSingleQuote = false;
        boolean inDoubleQuote = false;
        boolean inSingleLineComment = false;
        boolean inMultiLineComment = false;

        final ParseResult parseResult = new ParseResult(length);

        for (int i = 0; i < length; i++) {
            char currentChar = query.charAt(i);
            if (inSingleQuote) {
                if (currentChar == '\'') {
                    inSingleQuote = false; // '...'
                }
            } else if (inDoubleQuote) {
                if (currentChar == '"') {
                    inDoubleQuote = false; // "..."
                }
            } else if (inMultiLineComment) {
                if (currentChar == '*' && query.charAt(i + 1) == '/') {
                    inMultiLineComment = false; // */
                }
            } else if (inSingleLineComment) {
                if (currentChar == '\n') {
                    inSingleLineComment = false;
                }
            } else {
                if (currentChar == '\'') { // '...
                    inSingleQuote = true;
                } else if (currentChar == '"') {
                    inDoubleQuote = true;
                } else if (currentChar == '/' && query.charAt(i + 1) == '*') { // /*
                    inMultiLineComment = true;
                } else if (currentChar == '-' && query.charAt(i + 1) == '-') { // --
                    inSingleLineComment = true;
                } else if (currentChar == ':' //
                        && i + 1 < length //
                        && Character.isJavaIdentifierStart(query.charAt(i + 1))) {
                    int skipCharacters = i + 2;
                    while (skipCharacters < length && Character.isJavaIdentifierPart(query.charAt(skipCharacters))) {
                        skipCharacters++;
                    }
                    final String name = query.substring(i + 1, skipCharacters);
                    parseResult.addParameter(name);
                    currentChar = '?';
                    i += name.length();
                }
            }
            parseResult.append(currentChar);
        }

        return parseResult;
    }

    private static final class ParseResult {

        private final StringBuffer compiledSql;
        private final Map<String, List<Integer>> parameterName2IndexMap;
        private int parameterIndex;

        ParseResult(final int length) {
            this.parameterIndex = 1;
            this.compiledSql = new StringBuffer(length);
            this.parameterName2IndexMap = new HashMap<>();
        }

        void addParameter(final String parameterName) {

            final String normalizedName = normalizeParameterName(parameterName);
            List<Integer> list = parameterName2IndexMap.computeIfAbsent(normalizedName, k -> new ArrayList<>());
            list.add(parameterIndex++);
        }

        private static String normalizeParameterName(final String parameterName) {
            return parameterName.toLowerCase();
        }

        void append(final char character) {
            compiledSql.append(character);
        }

        String getCompiledSql() {
            return compiledSql.toString();
        }

        Collection<Integer> getParameterIndexes(final String parameterName) {

            final String normalizedName = normalizeParameterName(parameterName);
            final List<Integer> indexes = parameterName2IndexMap.get(normalizedName);

            if (indexes.isEmpty()) {
                throw new IllegalArgumentException(String.format("Parameter not found: '%s'", normalizedName));
            }
            return indexes;
        }

        boolean hasNamedParameter(final String parameterName) {
            return parameterName2IndexMap.containsKey(normalizeParameterName(parameterName));
        }

        boolean hasNamedParameters() {
            return !parameterName2IndexMap.isEmpty();
        }
    }
}
