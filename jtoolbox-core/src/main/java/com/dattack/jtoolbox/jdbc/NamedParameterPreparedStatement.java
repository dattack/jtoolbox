/*
 * Copyright (c) 2017, The Dattack team (http://www.dattack.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.dattack.jtoolbox.jdbc;

import java.io.InputStream;
import java.math.BigDecimal;
import java.sql.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Useful class to prepare and execute a SQL with parameter-name instead of parameter-index. The parameter-name is
 * identified by the format <i>:param_name</i>.
 *
 * @author cvarela
 * @since 0.2
 */
public class NamedParameterPreparedStatement extends DelegatingPreparedStatement {

    private final ParseResult parseResult;

    private static final class ParseResult {

        private int parameterIndex;
        private final StringBuffer compiledSql;
        private final Map<String, List<Integer>> parameterName2IndexMap;

        private static String normalizeParameterName(final String parameterName) {
            return parameterName.toLowerCase();
        }

        ParseResult(final int length) {
            this.parameterIndex = 1;
            this.compiledSql = new StringBuffer(length);
            this.parameterName2IndexMap = new HashMap<>();
        }

        void addParameter(final String parameterName) {

            final String normalizedName = normalizeParameterName(parameterName);
            List<Integer> list = parameterName2IndexMap.get(normalizedName);
            if (list == null) {
                list = new ArrayList<>();
                parameterName2IndexMap.put(normalizedName, list);
            }
            list.add(parameterIndex++);
        }

        void append(final char character) {
            compiledSql.append(character);
        }

        String getCompiledSql() {
            return compiledSql.toString();
        }

        Collection<Integer> getParameterIndexes(final String parameterName) {

            final String normalizedName = normalizeParameterName(parameterName);
            final List<Integer> indexes = parameterName2IndexMap.get(normalizedName);

            if (indexes.isEmpty()) {
                throw new IllegalArgumentException(String.format("Parameter not found: '%s'", normalizedName));
            }
            return indexes;
        }

        boolean hasNamedParameter(final String parameterName) {
            return parameterName2IndexMap.containsKey(normalizeParameterName(parameterName));
        }

        boolean hasNamedParameters() {
            return !parameterName2IndexMap.isEmpty();
        }
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection
     *            a connection (session) with a specific database.
     * @param sql
     *            a SQL statement that may contain one or more ':parameterName' IN parameter placeholders
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @exception SQLException
     *                if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql)
            throws SQLException {

        final ParseResult parseResult = parse(sql);

        return new NamedParameterPreparedStatement( //
                connection.prepareStatement(parseResult.getCompiledSql()), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection
     *            a connection (session) with a specific database.
     * @param sql
     *            a SQL statement that may contain one or more ':parameterName' IN parameter placeholders * @param
     * @param autoGeneratedKeys
     *            a flag indicating whether auto-generated keys should be returned
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @exception SQLException
     *                if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
            final int autoGeneratedKeys) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement( //
                connection.prepareStatement(parseResult.getCompiledSql(), autoGeneratedKeys), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection
     *            a connection (session) with a specific database.
     * @param sql
     *            a SQL statement that may contain one or more ':parameterName' IN parameter placeholders * @param
     * @param resultSetType
     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @param resultSetConcurrency
     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.CONCUR_READ_ONLY</code> or
     *            <code>ResultSet.CONCUR_UPDATABLE</code>
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @exception SQLException
     *                if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
            final int resultSetType, final int resultSetConcurrency) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement( //
                connection.prepareStatement(parseResult.getCompiledSql(), resultSetType, resultSetConcurrency), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection
     *            a connection (session) with a specific database.
     * @param sql
     *            a SQL statement that may contain one or more ':parameterName' IN parameter placeholders * @param
     * @param resultSetType
     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.TYPE_FORWARD_ONLY</code>,
     *            <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
     * @param resultSetConcurrency
     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.CONCUR_READ_ONLY</code> or
     *            <code>ResultSet.CONCUR_UPDATABLE</code>
     * @param resultSetHoldability
     *            one of the following <code>ResultSet</code> constants: <code>ResultSet.HOLD_CURSORS_OVER_COMMIT</code>
     *            or <code>ResultSet.CLOSE_CURSORS_AT_COMMIT</code>
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @exception SQLException
     *                if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
            final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability)
            throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement( //
                connection.prepareStatement(parseResult.getCompiledSql(), resultSetType, resultSetConcurrency,
                        resultSetHoldability), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection
     *            a connection (session) with a specific database.
     * @param sql
     *            a SQL statement that may contain one or more ':parameterName' IN parameter placeholders * @param
     * @param columnIndexes
     *            an array of column indexes indicating the columns that should be returned from the inserted row or
     *            rows
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @exception SQLException
     *                if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
            final int[] columnIndexes) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement( //
                connection.prepareStatement(parseResult.getCompiledSql(), columnIndexes), //
                parseResult);
    }

    /**
     * Creates a <code>NamedParameterPreparedStatement</code> object for sending parameterized SQL statements to the
     * database.
     *
     * @param connection
     *            a connection (session) with a specific database.
     * @param sql
     *            a SQL statement that may contain one or more ':parameterName' IN parameter placeholders * @param
     * @param columnNames
     *            an array of column names indicating the columns that should be returned from the inserted row or rows
     * @return a <code>NamedParameterPreparedStatement</code> object containing the pre-compiled SQL statement
     * @exception SQLException
     *                if a database access error occurs or this method is called on a closed connection
     */
    public static NamedParameterPreparedStatement build(final Connection connection, final String sql,
            final String[] columnNames) throws SQLException {
        final ParseResult parseResult = parse(sql);
        return new NamedParameterPreparedStatement( //
                connection.prepareStatement(parseResult.getCompiledSql(), columnNames), //
                parseResult);
    }

    /**
     * Parse the query string containing named parameters and result a parse result, which holds the parsed sql (named
     * parameters replaced by standard '?' parameters and an ordered list of the named parameters.
     *
     * @param query
     *            Query containing named parameters
     * @return ParseResult
     */
    private static ParseResult parse(final String query) {

        final int length = query.length();
        boolean inSingleQuote = false;
        boolean inDoubleQuote = false;
        boolean inSingleLineComment = false;
        boolean inMultiLineComment = false;

        final ParseResult parseResult = new ParseResult(length);

        for (int i = 0; i < length; i++) {
            char currentChar = query.charAt(i);
            if (inSingleQuote) {
                if (currentChar == '\'') {
                    inSingleQuote = false; // '...'
                }
            } else if (inDoubleQuote) {
                if (currentChar == '"') {
                    inDoubleQuote = false; // "..."
                }
            } else if (inMultiLineComment) {
                if (currentChar == '*' && query.charAt(i + 1) == '/') {
                    inMultiLineComment = false; // */
                }
            } else if (inSingleLineComment) {
                if (currentChar == '\n') {
                    inSingleLineComment = false;
                }
            } else {
                if (currentChar == '\'') { // '...
                    inSingleQuote = true;
                } else if (currentChar == '"') {
                    inDoubleQuote = true;
                } else if (currentChar == '/' && query.charAt(i + 1) == '*') { // /*
                    inMultiLineComment = true;
                } else if (currentChar == '-' && query.charAt(i + 1) == '-') { // --
                    inSingleLineComment = true;
                } else if (currentChar == ':' //
                        && i + 1 < length //
                        && Character.isJavaIdentifierStart(query.charAt(i + 1))) {
                    int skipCharacters = i + 2;
                    while (skipCharacters < length && Character.isJavaIdentifierPart(query.charAt(skipCharacters))) {
                        skipCharacters++;
                    }
                    final String name = query.substring(i + 1, skipCharacters);
                    parseResult.addParameter(name);
                    currentChar = '?';
                    i += name.length();
                }
            }
            parseResult.append(currentChar);
        }

        return parseResult;
    }

    private NamedParameterPreparedStatement(final PreparedStatement delegate, final ParseResult parseResult) {
        super(delegate);
        this.parseResult = parseResult;
    }

    public boolean hasNamedParameter(final String parameter) {
        return parseResult.hasNamedParameter(parameter);
    }

    public boolean hasNamedParameters() {
        return parseResult.hasNamedParameters();
    }

    /**
     * {@link #setAsciiStream(int, InputStream)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setAsciiStream(final String name, final InputStream value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setAsciiStream(i, value);
        }
    }

    /**
     * {@link #setBigDecimal(int, BigDecimal)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setBigDecimal(final String name, final BigDecimal value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setBigDecimal(i, value);
        }
    }

    /**
     * {@link #setBinaryStream(int, InputStream, int)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @param length
     *            the number of bytes in the stream
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setBinaryStream(final String name, final InputStream value, final int length) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setBinaryStream(i, value, length);
        }
    }

    /**
     * {@link #setBlob(int, Blob)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setBlob(final String name, final Blob value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setBlob(i, value);
        }
    }

    /**
     * {@link #setBoolean(int, boolean)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setBoolean(final String name, final boolean value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setBoolean(i, value);
        }
    }

    /**
     * {@link #setByte(int, byte)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setByte(final String name, final byte value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setByte(i, value);
        }
    }

    /**
     * {@link #setBytes(int, byte[])}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setBytes(final String name, final byte[] value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setBytes(i, value);
        }
    }

    /**
     * {@link #setClob(int, Clob)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setClob(final String name, final Clob value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setClob(i, value);
        }
    }

    /**
     * {@link #setDate(int, Date)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setDate(final String name, final Date value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setDate(i, value);
        }
    }

    /**
     * {@link #setDouble(int, double)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setDouble(final String name, final float value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setDouble(i, value);
        }
    }

    /**
     * {@link #setFloat(int, float)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setFloat(final String name, final float value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setFloat(i, value);
        }
    }

    /**
     * {@link #setInt(int, int)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setInt(final String name, final int value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setInt(i, value);
        }
    }

    /**
     * {@link #setLong(int, long)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setLong(final String name, final long value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setLong(i, value);
        }
    }

    /**
     * {@link #setNull(int, int)}.
     *
     * @param name
     *            the parameter name
     * @param sqlType
     *            the SQL type code defined in <code>java.sql.Types</code>
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setNull(final String name, final int sqlType) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setNull(i, sqlType);
        }
    }

    /**
     * {@link #setObject(int, Object)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String name, final Object value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setObject(i, value);
        }
    }

    /**
     * {@link #setObject(int, Object, int)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @param targetSqlType
     *            the SQL type (as defined in java.sql.Types) to be sent to the database. The scale argument may further
     *            qualify this type.
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String name, final Object value, final int targetSqlType) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setObject(i, value, targetSqlType);
        }
    }

    /**
     * {@link #setObject(int, Object, int, int)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @param targetSqlType
     *            the SQL type (as defined in java.sql.Types) to be sent to the database. The scale argument may further
     *            qualify this type.
     * @param scaleOrLength
     *            for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types, this is the number of digits after the
     *            decimal point. For Java Object types InputStream and Reader, this is the length of the data in the
     *            stream or reader. For all other types, this value will be ignored.
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setObject(final String name, final Object value, final int targetSqlType, final int scaleOrLength)
            throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setObject(i, value, targetSqlType, scaleOrLength);
        }
    }

    /**
     * {@link #setShort(int, short)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setShort(final String name, final short value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setShort(i, value);
        }
    }

    /**
     * {@link #setString(int, String)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setString(final String name, final String value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setString(i, value);
        }
    }

    /**
     * {@link #setTime(int, Time)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setTime(final String name, final Time value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setTime(i, value);
        }
    }

    /**
     * {@link #setTimestamp(int, Timestamp)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setTimestamp(final String name, final Timestamp value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setTimestamp(i, value);
        }
    }

    /**
     * {@link #setUnicodeStream(int, InputStream, int)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            a java.io.InputStream object that contains the Unicode parameter value
     * @param length
     *            the number of bytes in the stream
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    @Deprecated
    public void setUnicodeStream(final String name, final InputStream value, final int length) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setUnicodeStream(i, value, length);
        }
    }

    /**
     * {@link #setSQLXML(int, SQLXML)}.
     *
     * @param name
     *            the parameter name
     * @param value
     *            the parameter value
     * @throws SQLException
     *             if parameterName does not correspond to a parameter marker in the SQL statement; if a database access
     *             error occurs or this method is called on a closed PreparedStatement
     */
    public void setSQLXML(final String name, SQLXML value) throws SQLException {
        for (final Integer i : parseResult.getParameterIndexes(name)) {
            getDelegate().setSQLXML(i, value);
        }
    }
}
